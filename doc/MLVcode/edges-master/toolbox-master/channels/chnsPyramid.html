<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of chnsPyramid</title>
  <meta name="keywords" content="chnsPyramid">
  <meta name="description" content="Compute channel feature pyramid given an input image.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">channels</a> &gt; chnsPyramid.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\channels&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>chnsPyramid
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Compute channel feature pyramid given an input image.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function pyramid = chnsPyramid( I, varargin ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute channel feature pyramid given an input image.

 While chnsCompute() computes channel features at a single scale,
 chnsPyramid() calls chnsCompute() multiple times on different scale
 images to create a scale-space pyramid of channel features.

 In its simplest form, chnsPyramid() first creates an image pyramid, then
 calls chnsCompute() with the specified &quot;pChns&quot; on each scale of the image
 pyramid. The parameter &quot;nPerOct&quot; determines the number of scales per
 octave in the image pyramid (an octave is the set of scales up to half of
 the initial scale), a typical value is nPerOct=8 in which case each scale
 in the pyramid is 2^(-1/8)~=.917 times the size of the previous. The
 smallest scale of the pyramid is determined by &quot;minDs&quot;, once either image
 dimension in the resized image falls below minDs, pyramid creation stops.
 The largest scale in the pyramid is determined by &quot;nOctUp&quot; which
 determines the number of octaves to compute above the original scale.

 While calling chnsCompute() on each image scale works, it is unnecessary.
 For a broad family of features, including gradient histograms and all
 channel types tested, the feature responses computed at a single scale
 can be used to approximate feature responses at nearby scales. The
 approximation is accurate at least within an entire scale octave. For
 details and to understand why this unexpected result holds, please see:
   P. Dollár, R. Appel, S. Belongie and P. Perona
   &quot;Fast Feature Pyramids for Object Detection&quot;, PAMI 2014.

 The parameter &quot;nApprox&quot; determines how many intermediate scales are
 approximated using the techniques described in the above paper. Roughly
 speaking, channels at approximated scales are computed by taking the
 corresponding channel at the nearest true scale (computed w chnsCompute)
 and resampling and re-normalizing it appropriately. For example, if
 nPerOct=8 and nApprox=7, then the 7 intermediate scales are approximated
 and only power of two scales are actually computed (using chnsCompute).
 The parameter &quot;lambdas&quot; determines how the channels are normalized (see
 the above paper). lambdas for a given set of channels can be computed
 using chnsScaling.m, alternatively, if no lambdas are specified, the
 lambdas are automatically approximated using two true image scales.

 Typically approximating all scales within an octave (by setting
 nApprox=nPerOct-1 or nApprox=-1) works well, and results in large speed
 gains (~4x). See example below for a visualization of the pyramid
 computed with and without the approximation. While there is a slight
 difference in the channels, during detection the approximated channels
 have been shown to be essentially as effective as the original channels.

 While every effort is made to space the image scales evenly, this is not
 always possible. For example, given a 101x100 image, it is impossible to
 downsample it by exactly 1/2 along the first dimension, moreover, the
 exact scaling along the two dimensions will differ. Instead, the scales
 are tweaked slightly (e.g. for a 101x101 image the scale would go from
 1/2 to something like 50/101), and the output contains the exact scaling
 factors used for both the heights and the widths (&quot;scaleshw&quot;) and also
 the approximate scale for both dimensions (&quot;scales&quot;). If &quot;shrink&quot;&gt;1 the
 scales are further tweaked so that the resized image has dimensions that
 are exactly divisible by shrink (for details please see the code).

 If chnsPyramid() is called with no inputs, the output is the complete
 default parameters (pPyramid). Finally, we describe the remaining
 parameters: &quot;pad&quot; controls the amount the channels are padded after being
 created (useful for detecting objects near boundaries); &quot;smooth&quot; controls
 the amount of smoothing after the channels are created (and controls the
 integration scale of the channels); finally &quot;concat&quot; determines whether
 all channels at a single scale are concatenated in the output.

 An emphasis has been placed on speed, with the code undergoing heavy
 optimization. Computing the full set of (approximated) *multi-scale*
 channels on a 480x640 image runs over *30 fps* on a single core of a
 machine from 2011 (although runtime depends on input parameters).

 USAGE
  pPyramid = chnsPyramid()
  pyramid = chnsPyramid( I, pPyramid )

 INPUTS
  I            - [hxwx3] input image (uint8 or single/double in [0,1])
  pPyramid     - parameters (struct or name/value pairs)
   .pChns        - parameters for creating channels (see chnsCompute.m)
   .nPerOct      - [8] number of scales per octave
   .nOctUp       - [0] number of upsampled octaves to compute
   .nApprox      - [-1] number of approx. scales (if -1 nApprox=nPerOct-1)
   .lambdas      - [] coefficients for power law scaling (see BMVC10)
   .pad          - [0 0] amount to pad channels (along T/B and L/R)
   .minDs        - [16 16] minimum image size for channel computation
   .smooth       - [1] radius for channel smoothing (using convTri)
   .concat       - [1] if true concatenate channels
   .complete     - [] if true does not check/set default vals in pPyramid

 OUTPUTS
  pyramid      - output struct
   .pPyramid     - exact input parameters used (may change from input)
   .nTypes       - number of channel types
   .nScales      - number of scales computed
   .data         - [nScales x nTypes] cell array of computed channels
   .info         - [nTypes x 1] struct array (mirrored from chnsCompute)
   .lambdas      - [nTypes x 1] scaling coefficients actually used
   .scales       - [nScales x 1] relative scales (approximate)
   .scaleshw     - [nScales x 2] exact scales for resampling h and w

 EXAMPLE
  I=imResample(imread('peppers.png'),[480 640]);
  pPyramid=chnsPyramid(); pPyramid.minDs=[128 128];
  pPyramid.nApprox=0; tic, P1=chnsPyramid(I,pPyramid); toc
  pPyramid.nApprox=7; tic, P2=chnsPyramid(I,pPyramid); toc
  figure(1); montage2(P1.data{2}); figure(2); montage2(P2.data{2});
  figure(3); montage2(abs(P1.data{2}-P2.data{2})); colorbar;

 See also <a href="chnsCompute.html" class="code" title="function chns = chnsCompute( I, varargin )">chnsCompute</a>, <a href="chnsScaling.html" class="code" title="function [lambdas,as,scales,fs] = chnsScaling( pChns, Is, show )">chnsScaling</a>, <a href="convTri.html" class="code" title="function J = convTri( I, r, s, nomex )">convTri</a>, <a href="imPad.html" class="code" title="function J = imPad( I, pad, type )">imPad</a>

 Piotr's Computer Vision Matlab Toolbox      Version 3.25
 Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="chnsCompute.html" class="code" title="function chns = chnsCompute( I, varargin )">chnsCompute</a>	Compute channel features at a single scale given an input image.</li><li><a href="convTri.html" class="code" title="function J = convTri( I, r, s, nomex )">convTri</a>	Extremely fast 2D image convolution with a triangle filter.</li><li><a href="imPad.html" class="code" title="function J = imPad( I, pad, type )">imPad</a>	Pad an image along its four boundaries.</li><li><a href="rgbConvert.html" class="code" title="function J = rgbConvert( I, colorSpace, useSingle )">rgbConvert</a>	Convert RGB image to other color spaces (highly optimized).</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="chnsScaling.html" class="code" title="function [lambdas,as,scales,fs] = chnsScaling( pChns, Is, show )">chnsScaling</a>	Compute lambdas for channel power law scaling.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [scales,scaleshw] = getScales(nPerOct,nOctUp,minDs,shrink,sz)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function pyramid = chnsPyramid( I, varargin )</a>
0002 <span class="comment">% Compute channel feature pyramid given an input image.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% While chnsCompute() computes channel features at a single scale,</span>
0005 <span class="comment">% chnsPyramid() calls chnsCompute() multiple times on different scale</span>
0006 <span class="comment">% images to create a scale-space pyramid of channel features.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% In its simplest form, chnsPyramid() first creates an image pyramid, then</span>
0009 <span class="comment">% calls chnsCompute() with the specified &quot;pChns&quot; on each scale of the image</span>
0010 <span class="comment">% pyramid. The parameter &quot;nPerOct&quot; determines the number of scales per</span>
0011 <span class="comment">% octave in the image pyramid (an octave is the set of scales up to half of</span>
0012 <span class="comment">% the initial scale), a typical value is nPerOct=8 in which case each scale</span>
0013 <span class="comment">% in the pyramid is 2^(-1/8)~=.917 times the size of the previous. The</span>
0014 <span class="comment">% smallest scale of the pyramid is determined by &quot;minDs&quot;, once either image</span>
0015 <span class="comment">% dimension in the resized image falls below minDs, pyramid creation stops.</span>
0016 <span class="comment">% The largest scale in the pyramid is determined by &quot;nOctUp&quot; which</span>
0017 <span class="comment">% determines the number of octaves to compute above the original scale.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% While calling chnsCompute() on each image scale works, it is unnecessary.</span>
0020 <span class="comment">% For a broad family of features, including gradient histograms and all</span>
0021 <span class="comment">% channel types tested, the feature responses computed at a single scale</span>
0022 <span class="comment">% can be used to approximate feature responses at nearby scales. The</span>
0023 <span class="comment">% approximation is accurate at least within an entire scale octave. For</span>
0024 <span class="comment">% details and to understand why this unexpected result holds, please see:</span>
0025 <span class="comment">%   P. Dollár, R. Appel, S. Belongie and P. Perona</span>
0026 <span class="comment">%   &quot;Fast Feature Pyramids for Object Detection&quot;, PAMI 2014.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% The parameter &quot;nApprox&quot; determines how many intermediate scales are</span>
0029 <span class="comment">% approximated using the techniques described in the above paper. Roughly</span>
0030 <span class="comment">% speaking, channels at approximated scales are computed by taking the</span>
0031 <span class="comment">% corresponding channel at the nearest true scale (computed w chnsCompute)</span>
0032 <span class="comment">% and resampling and re-normalizing it appropriately. For example, if</span>
0033 <span class="comment">% nPerOct=8 and nApprox=7, then the 7 intermediate scales are approximated</span>
0034 <span class="comment">% and only power of two scales are actually computed (using chnsCompute).</span>
0035 <span class="comment">% The parameter &quot;lambdas&quot; determines how the channels are normalized (see</span>
0036 <span class="comment">% the above paper). lambdas for a given set of channels can be computed</span>
0037 <span class="comment">% using chnsScaling.m, alternatively, if no lambdas are specified, the</span>
0038 <span class="comment">% lambdas are automatically approximated using two true image scales.</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% Typically approximating all scales within an octave (by setting</span>
0041 <span class="comment">% nApprox=nPerOct-1 or nApprox=-1) works well, and results in large speed</span>
0042 <span class="comment">% gains (~4x). See example below for a visualization of the pyramid</span>
0043 <span class="comment">% computed with and without the approximation. While there is a slight</span>
0044 <span class="comment">% difference in the channels, during detection the approximated channels</span>
0045 <span class="comment">% have been shown to be essentially as effective as the original channels.</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% While every effort is made to space the image scales evenly, this is not</span>
0048 <span class="comment">% always possible. For example, given a 101x100 image, it is impossible to</span>
0049 <span class="comment">% downsample it by exactly 1/2 along the first dimension, moreover, the</span>
0050 <span class="comment">% exact scaling along the two dimensions will differ. Instead, the scales</span>
0051 <span class="comment">% are tweaked slightly (e.g. for a 101x101 image the scale would go from</span>
0052 <span class="comment">% 1/2 to something like 50/101), and the output contains the exact scaling</span>
0053 <span class="comment">% factors used for both the heights and the widths (&quot;scaleshw&quot;) and also</span>
0054 <span class="comment">% the approximate scale for both dimensions (&quot;scales&quot;). If &quot;shrink&quot;&gt;1 the</span>
0055 <span class="comment">% scales are further tweaked so that the resized image has dimensions that</span>
0056 <span class="comment">% are exactly divisible by shrink (for details please see the code).</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% If chnsPyramid() is called with no inputs, the output is the complete</span>
0059 <span class="comment">% default parameters (pPyramid). Finally, we describe the remaining</span>
0060 <span class="comment">% parameters: &quot;pad&quot; controls the amount the channels are padded after being</span>
0061 <span class="comment">% created (useful for detecting objects near boundaries); &quot;smooth&quot; controls</span>
0062 <span class="comment">% the amount of smoothing after the channels are created (and controls the</span>
0063 <span class="comment">% integration scale of the channels); finally &quot;concat&quot; determines whether</span>
0064 <span class="comment">% all channels at a single scale are concatenated in the output.</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% An emphasis has been placed on speed, with the code undergoing heavy</span>
0067 <span class="comment">% optimization. Computing the full set of (approximated) *multi-scale*</span>
0068 <span class="comment">% channels on a 480x640 image runs over *30 fps* on a single core of a</span>
0069 <span class="comment">% machine from 2011 (although runtime depends on input parameters).</span>
0070 <span class="comment">%</span>
0071 <span class="comment">% USAGE</span>
0072 <span class="comment">%  pPyramid = chnsPyramid()</span>
0073 <span class="comment">%  pyramid = chnsPyramid( I, pPyramid )</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% INPUTS</span>
0076 <span class="comment">%  I            - [hxwx3] input image (uint8 or single/double in [0,1])</span>
0077 <span class="comment">%  pPyramid     - parameters (struct or name/value pairs)</span>
0078 <span class="comment">%   .pChns        - parameters for creating channels (see chnsCompute.m)</span>
0079 <span class="comment">%   .nPerOct      - [8] number of scales per octave</span>
0080 <span class="comment">%   .nOctUp       - [0] number of upsampled octaves to compute</span>
0081 <span class="comment">%   .nApprox      - [-1] number of approx. scales (if -1 nApprox=nPerOct-1)</span>
0082 <span class="comment">%   .lambdas      - [] coefficients for power law scaling (see BMVC10)</span>
0083 <span class="comment">%   .pad          - [0 0] amount to pad channels (along T/B and L/R)</span>
0084 <span class="comment">%   .minDs        - [16 16] minimum image size for channel computation</span>
0085 <span class="comment">%   .smooth       - [1] radius for channel smoothing (using convTri)</span>
0086 <span class="comment">%   .concat       - [1] if true concatenate channels</span>
0087 <span class="comment">%   .complete     - [] if true does not check/set default vals in pPyramid</span>
0088 <span class="comment">%</span>
0089 <span class="comment">% OUTPUTS</span>
0090 <span class="comment">%  pyramid      - output struct</span>
0091 <span class="comment">%   .pPyramid     - exact input parameters used (may change from input)</span>
0092 <span class="comment">%   .nTypes       - number of channel types</span>
0093 <span class="comment">%   .nScales      - number of scales computed</span>
0094 <span class="comment">%   .data         - [nScales x nTypes] cell array of computed channels</span>
0095 <span class="comment">%   .info         - [nTypes x 1] struct array (mirrored from chnsCompute)</span>
0096 <span class="comment">%   .lambdas      - [nTypes x 1] scaling coefficients actually used</span>
0097 <span class="comment">%   .scales       - [nScales x 1] relative scales (approximate)</span>
0098 <span class="comment">%   .scaleshw     - [nScales x 2] exact scales for resampling h and w</span>
0099 <span class="comment">%</span>
0100 <span class="comment">% EXAMPLE</span>
0101 <span class="comment">%  I=imResample(imread('peppers.png'),[480 640]);</span>
0102 <span class="comment">%  pPyramid=chnsPyramid(); pPyramid.minDs=[128 128];</span>
0103 <span class="comment">%  pPyramid.nApprox=0; tic, P1=chnsPyramid(I,pPyramid); toc</span>
0104 <span class="comment">%  pPyramid.nApprox=7; tic, P2=chnsPyramid(I,pPyramid); toc</span>
0105 <span class="comment">%  figure(1); montage2(P1.data{2}); figure(2); montage2(P2.data{2});</span>
0106 <span class="comment">%  figure(3); montage2(abs(P1.data{2}-P2.data{2})); colorbar;</span>
0107 <span class="comment">%</span>
0108 <span class="comment">% See also chnsCompute, chnsScaling, convTri, imPad</span>
0109 <span class="comment">%</span>
0110 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.25</span>
0111 <span class="comment">% Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]</span>
0112 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0113 
0114 <span class="comment">% get default parameters pPyramid</span>
0115 <span class="keyword">if</span>(nargin==2), p=varargin{1}; <span class="keyword">else</span> p=[]; <span class="keyword">end</span>
0116 <span class="keyword">if</span>( ~isfield(p,<span class="string">'complete'</span>) || p.complete~=1 || isempty(I) )
0117   dfs={ <span class="string">'pChns'</span>,{}, <span class="string">'nPerOct'</span>,8, <span class="string">'nOctUp'</span>,0, <span class="string">'nApprox'</span>,-1, <span class="keyword">...</span>
0118     <span class="string">'lambdas'</span>,[], <span class="string">'pad'</span>,[0 0], <span class="string">'minDs'</span>,[16 16], <span class="keyword">...</span>
0119     <span class="string">'smooth'</span>,1, <span class="string">'concat'</span>,1, <span class="string">'complete'</span>,1 };
0120   p=getPrmDflt(varargin,dfs,1); chns=<a href="chnsCompute.html" class="code" title="function chns = chnsCompute( I, varargin )">chnsCompute</a>([],p.pChns);
0121   p.pChns=chns.pChns; p.pChns.complete=1; shrink=p.pChns.shrink;
0122   p.pad=round(p.pad/shrink)*shrink; p.minDs=max(p.minDs,shrink*4);
0123   <span class="keyword">if</span>(p.nApprox&lt;0), p.nApprox=p.nPerOct-1; <span class="keyword">end</span>
0124 <span class="keyword">end</span>
0125 <span class="keyword">if</span>(nargin==0), pyramid=p; <span class="keyword">return</span>; <span class="keyword">end</span>; pPyramid=p;
0126 vs=struct2cell(p); [pChns,nPerOct,nOctUp,nApprox,lambdas,<span class="keyword">...</span>
0127   pad,minDs,smooth,concat,~]=deal(vs{:}); shrink=pChns.shrink;
0128 
0129 <span class="comment">% convert I to appropriate color space (or simply normalize)</span>
0130 cs=pChns.pColor.colorSpace; sz=[size(I,1) size(I,2)];
0131 <span class="keyword">if</span>(~all(sz==0) &amp;&amp; size(I,3)==1 &amp;&amp; ~any(strcmpi(cs,{<span class="string">'gray'</span>,<span class="string">'orig'</span>}))),
0132   I=I(:,:,[1 1 1]); warning(<span class="string">'Converting image to color'</span>); <span class="keyword">end</span> <span class="comment">%#ok&lt;WNTAG&gt;</span>
0133 I=<a href="rgbConvert.html" class="code" title="function J = rgbConvert( I, colorSpace, useSingle )">rgbConvert</a>(I,cs); pChns.pColor.colorSpace=<span class="string">'orig'</span>;
0134 
0135 <span class="comment">% get scales at which to compute features and list of real/approx scales</span>
0136 [scales,scaleshw]=<a href="#_sub1" class="code" title="subfunction [scales,scaleshw] = getScales(nPerOct,nOctUp,minDs,shrink,sz)">getScales</a>(nPerOct,nOctUp,minDs,shrink,sz);
0137 nScales=length(scales); <span class="keyword">if</span>(1), isR=1; <span class="keyword">else</span> isR=1+nOctUp*nPerOct; <span class="keyword">end</span>
0138 isR=isR:nApprox+1:nScales; isA=1:nScales; isA(isR)=[];
0139 j=[0 floor((isR(1:end-1)+isR(2:end))/2) nScales];
0140 isN=1:nScales; <span class="keyword">for</span> i=1:length(isR), isN(j(i)+1:j(i+1))=isR(i); <span class="keyword">end</span>
0141 nTypes=0; data=cell(nScales,nTypes); info=struct([]);
0142 
0143 <span class="comment">% compute image pyramid [real scales]</span>
0144 <span class="keyword">for</span> i=isR
0145   s=scales(i); sz1=round(sz*s/shrink)*shrink;
0146   <span class="keyword">if</span>(all(sz==sz1)), I1=I; <span class="keyword">else</span> I1=imResampleMex(I,sz1(1),sz1(2),1); <span class="keyword">end</span>
0147   <span class="keyword">if</span>(s==.5 &amp;&amp; (nApprox&gt;0 || nPerOct==1)), I=I1; <span class="keyword">end</span>
0148   chns=<a href="chnsCompute.html" class="code" title="function chns = chnsCompute( I, varargin )">chnsCompute</a>(I1,pChns); info=chns.info;
0149   <span class="keyword">if</span>(i==isR(1)), nTypes=chns.nTypes; data=cell(nScales,nTypes); <span class="keyword">end</span>
0150   data(i,:) = chns.data;
0151 <span class="keyword">end</span>
0152 
0153 <span class="comment">% if lambdas not specified compute image specific lambdas</span>
0154 <span class="keyword">if</span>( nScales&gt;0 &amp;&amp; nApprox&gt;0 &amp;&amp; isempty(lambdas) )
0155   is=1+nOctUp*nPerOct:nApprox+1:nScales;
0156   assert(length(is)&gt;=2); <span class="keyword">if</span>(length(is)&gt;2), is=is(2:3); <span class="keyword">end</span>
0157   f0=zeros(1,nTypes); f1=f0; d0=data(is(1),:); d1=data(is(2),:);
0158   <span class="keyword">for</span> j=1:nTypes, d=d0{j}; f0(j)=sum(d(:))/numel(d); <span class="keyword">end</span>
0159   <span class="keyword">for</span> j=1:nTypes, d=d1{j}; f1(j)=sum(d(:))/numel(d); <span class="keyword">end</span>
0160   lambdas = - log2(f0./f1) / log2(scales(is(1))/scales(is(2)));
0161 <span class="keyword">end</span>
0162 
0163 <span class="comment">% compute image pyramid [approximated scales]</span>
0164 <span class="keyword">for</span> i=isA
0165   iR=isN(i); sz1=round(sz*scales(i)/shrink);
0166   <span class="keyword">for</span> j=1:nTypes, ratio=(scales(i)/scales(iR)).^-lambdas(j);
0167     data{i,j}=imResampleMex(data{iR,j},sz1(1),sz1(2),ratio); <span class="keyword">end</span>
0168 <span class="keyword">end</span>
0169 
0170 <span class="comment">% smooth channels, optionally pad and concatenate channels</span>
0171 <span class="keyword">for</span> i=1:nScales*nTypes, data{i}=<a href="convTri.html" class="code" title="function J = convTri( I, r, s, nomex )">convTri</a>(data{i},smooth); <span class="keyword">end</span>
0172 <span class="keyword">if</span>(any(pad)), <span class="keyword">for</span> i=1:nScales, <span class="keyword">for</span> j=1:nTypes
0173       data{i,j}=<a href="imPad.html" class="code" title="function J = imPad( I, pad, type )">imPad</a>(data{i,j},pad/shrink,info(j).padWith); <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="keyword">end</span>
0174 <span class="keyword">if</span>(concat &amp;&amp; nTypes), data0=data; data=cell(nScales,1); <span class="keyword">end</span>
0175 <span class="keyword">if</span>(concat &amp;&amp; nTypes), <span class="keyword">for</span> i=1:nScales, data{i}=cat(3,data0{i,:}); <span class="keyword">end</span>; <span class="keyword">end</span>
0176 
0177 <span class="comment">% create output struct</span>
0178 j=info; <span class="keyword">if</span>(~isempty(j)), j=find(strcmp(<span class="string">'color channels'</span>,{j.name})); <span class="keyword">end</span>
0179 <span class="keyword">if</span>(~isempty(j)), info(j).pChn.colorSpace=cs; <span class="keyword">end</span>
0180 pyramid = struct( <span class="string">'pPyramid'</span>,pPyramid, <span class="string">'nTypes'</span>,nTypes, <span class="keyword">...</span>
0181   <span class="string">'nScales'</span>,nScales, <span class="string">'data'</span>,{data}, <span class="string">'info'</span>,info, <span class="string">'lambdas'</span>,lambdas, <span class="keyword">...</span>
0182   <span class="string">'scales'</span>,scales, <span class="string">'scaleshw'</span>,scaleshw );
0183 
0184 <span class="keyword">end</span>
0185 
0186 <a name="_sub1" href="#_subfunctions" class="code">function [scales,scaleshw] = getScales(nPerOct,nOctUp,minDs,shrink,sz)</a>
0187 <span class="comment">% set each scale s such that max(abs(round(sz*s/shrink)*shrink-sz*s)) is</span>
0188 <span class="comment">% minimized without changing the smaller dim of sz (tricky algebra)</span>
0189 <span class="keyword">if</span>(any(sz==0)), scales=[]; scaleshw=[]; <span class="keyword">return</span>; <span class="keyword">end</span>
0190 nScales = floor(nPerOct*(nOctUp+log2(min(sz./minDs)))+1);
0191 scales = 2.^(-(0:nScales-1)/nPerOct+nOctUp);
0192 <span class="keyword">if</span>(sz(1)&lt;sz(2)), d0=sz(1); d1=sz(2); <span class="keyword">else</span> d0=sz(2); d1=sz(1); <span class="keyword">end</span>
0193 <span class="keyword">for</span> i=1:nScales, s=scales(i);
0194   s0=(round(d0*s/shrink)*shrink-.25*shrink)./d0;
0195   s1=(round(d0*s/shrink)*shrink+.25*shrink)./d0;
0196   ss=(0:.01:1-eps)*(s1-s0)+s0;
0197   es0=d0*ss; es0=abs(es0-round(es0/shrink)*shrink);
0198   es1=d1*ss; es1=abs(es1-round(es1/shrink)*shrink);
0199   [~,x]=min(max(es0,es1)); scales(i)=ss(x);
0200 <span class="keyword">end</span>
0201 kp=[scales(1:end-1)~=scales(2:end) true]; scales=scales(kp);
0202 scaleshw = [round(sz(1)*scales/shrink)*shrink/sz(1);
0203   round(sz(2)*scales/shrink)*shrink/sz(2)]';
0204 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 15:20:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>