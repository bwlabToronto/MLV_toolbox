<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of chnsCompute</title>
  <meta name="keywords" content="chnsCompute">
  <meta name="description" content="Compute channel features at a single scale given an input image.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">channels</a> &gt; chnsCompute.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\channels&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>chnsCompute
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Compute channel features at a single scale given an input image.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function chns = chnsCompute( I, varargin ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Compute channel features at a single scale given an input image.

 Compute the channel features as described in:
  P. Dollár, Z. Tu, P. Perona and S. Belongie
  &quot;Integral Channel Features&quot;, BMVC 2009.
 Channel features have proven very effective in sliding window object
 detection, both in terms of *accuracy* and *speed*. Numerous feature
 types including histogram of gradients (hog) can be converted into
 channel features, and overall, channels are general and powerful.

 Given an input image I, a corresponding channel is a registered map of I,
 where the output pixels are computed from corresponding patches of input
 pixels (thus preserving overall image layout). A trivial channel is
 simply the input grayscale image, likewise for a color image each color
 channel can serve as a channel. Other channels can be computed using
 linear or non-linear transformations of I, various choices implemented
 here are described below. The only constraint is that channels must be
 translationally invariant (i.e. translating the input image or the
 resulting channels gives the same result). This allows for fast object
 detection, as the channels can be computed once on the entire image
 rather than separately for each overlapping detection window.

 Currently, three channel types are available by default (to date, these
 have proven the most effective for sliding window object detection):
  (1) color channels (computed using rgbConvert.m)
  (2) gradient magnitude (computed using gradientMag.m)
  (3) quantized gradient channels (computed using gradientHist.m)
 For more information about each channel type, including the exact input
 parameters and their meanings, see the respective m-files which perform
 the actual computatons (chnsCompute is essentially a wrapper function).
 The converted color channels serve as input to gradientMag/gradientHist.

 Additionally, custom channels can be specified via an optional struct
 array &quot;pCustom&quot; which may have 0 or more custom channel definitions. Each
 custom channel is generated via a call to &quot;chns=feval(hFunc,I,pFunc{:})&quot;.
 The color space of I is determined by pColor.colorSpace, use the setting
 colorSpace='orig' if the input image is not an 'rgb' image and should be
 left unchanged (e.g. if I has multiple channels). The input I will have
 type single and the output of hFunc should also have type single.

 &quot;shrink&quot; (which should be an integer) determines the amount to subsample
 the computed channels (in applications such as detection subsamping does
 not affect performance). The params for each channel type are described
 in detail in the respective function. In addition, each channel type has
 a param &quot;enabled&quot; that determines if the channel is computed. If
 chnsCompute() is called with no inputs, the output is the complete
 default params (pChns). Otherwise the outputs are the computed channels
 and additional meta-data (see below). The channels are computed at a
 single scale, for (fast) multi-scale channel computation see chnsPyramid.

 An emphasis has been placed on speed, with the code undergoing heavy
 optimization. Computing the full set of channels used in the BMVC09 paper
 referenced above on a 480x640 image runs over *100 fps* on a single core
 of a machine from 2011 (although runtime depends on input parameters).

 USAGE
  pChns = chnsCompute()
  chns = chnsCompute( I, pChns )

 INPUTS
  I           - [hxwx3] input image (uint8 or single/double in [0,1])
  pChns       - parameters (struct or name/value pairs)
   .shrink       - [4] integer downsampling amount for channels
   .pColor       - parameters for color space:
     .enabled      - [1] if true enable color channels
     .smooth       - [1] radius for image smoothing (using convTri)
     .colorSpace   - ['luv'] choices are: 'gray', 'rgb', 'hsv', 'orig'
   .pGradMag     - parameters for gradient magnitude:
     .enabled      - [1] if true enable gradient magnitude channel
     .colorChn     - [0] if&gt;0 color channel to use for grad computation
     .normRad      - [5] normalization radius for gradient
     .normConst    - [.005] normalization constant for gradient
     .full         - [0] if true compute angles in [0,2*pi) else in [0,pi)
   .pGradHist    - parameters for gradient histograms:
     .enabled      - [1] if true enable gradient histogram channels
     .binSize      - [shrink] spatial bin size (defaults to shrink)
     .nOrients     - [6] number of orientation channels
     .softBin      - [0] if true use &quot;soft&quot; bilinear spatial binning
     .useHog       - [0] if true perform 4-way hog normalization/clipping
     .clipHog      - [.2] value at which to clip hog histogram bins
   .pCustom      - parameters for custom channels (optional struct array):
     .enabled      - [1] if true enable custom channel type
     .name         - ['REQ'] custom channel type name
     .hFunc        - ['REQ'] function handle for computing custom channels
     .pFunc        - [{}] additional params for chns=hFunc(I,pFunc{:})
     .padWith      - [0] how channel should be padded (e.g. 0,'replicate')
   .complete     - [] if true does not check/set default vals in pChns

 OUTPUTS
  chns       - output struct
   .pChns      - exact input parameters used
   .nTypes     - number of channel types
   .data       - [nTypes x 1] cell [h/shrink x w/shrink x nChns] channels
   .info       - [nTypes x 1] struct array
     .name       - channel type name
     .pChn       - exact input parameters for given channel type
     .nChns      - number of channels for given channel type
     .padWith    - how channel should be padded (0,'replicate')

 EXAMPLE - default channels
  I=imResample(imread('peppers.png'),[480 640]); pChns=chnsCompute();
  tic, for i=1:100, chns=chnsCompute(I,pChns); end; toc
  figure(1); montage2(cat(3,chns.data{:}));

 EXAMPLE - default + custom channels
  I=imResample(imread('peppers.png'),[480 640]); pChns=chnsCompute();
  hFunc=@(I) 5*sqrt(max(0,max(convBox(I.^2,2)-convBox(I,2).^2,[],3)));
  pChns.pCustom=struct('name','Std02','hFunc',hFunc); pChns.complete=0;
  tic, chns=chnsCompute(I,pChns); toc
  figure(1); im(chns.data{4});

 See also <a href="rgbConvert.html" class="code" title="function J = rgbConvert( I, colorSpace, useSingle )">rgbConvert</a>, <a href="gradientMag.html" class="code" title="function [M,O] = gradientMag( I, channel, normRad, normConst, full )">gradientMag</a>, <a href="gradientHist.html" class="code" title="function H = gradientHist( M, O, varargin )">gradientHist</a>, <a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>

 Piotr's Computer Vision Matlab Toolbox      Version 3.23
 Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="convTri.html" class="code" title="function J = convTri( I, r, s, nomex )">convTri</a>	Extremely fast 2D image convolution with a triangle filter.</li><li><a href="gradientHist.html" class="code" title="function H = gradientHist( M, O, varargin )">gradientHist</a>	Compute oriented gradient histograms.</li><li><a href="gradientMag.html" class="code" title="function [M,O] = gradientMag( I, channel, normRad, normConst, full )">gradientMag</a>	Compute gradient magnitude and orientation at each image location.</li><li><a href="rgbConvert.html" class="code" title="function J = rgbConvert( I, colorSpace, useSingle )">rgbConvert</a>	Convert RGB image to other color spaces (highly optimized).</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="chnsPyramid.html" class="code" title="function pyramid = chnsPyramid( I, varargin )">chnsPyramid</a>	Compute channel feature pyramid given an input image.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function chns = addChn( chns, data, name, pChn, padWith, h, w )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function chns = chnsCompute( I, varargin )</a>
0002 <span class="comment">% Compute channel features at a single scale given an input image.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Compute the channel features as described in:</span>
0005 <span class="comment">%  P. Dollár, Z. Tu, P. Perona and S. Belongie</span>
0006 <span class="comment">%  &quot;Integral Channel Features&quot;, BMVC 2009.</span>
0007 <span class="comment">% Channel features have proven very effective in sliding window object</span>
0008 <span class="comment">% detection, both in terms of *accuracy* and *speed*. Numerous feature</span>
0009 <span class="comment">% types including histogram of gradients (hog) can be converted into</span>
0010 <span class="comment">% channel features, and overall, channels are general and powerful.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Given an input image I, a corresponding channel is a registered map of I,</span>
0013 <span class="comment">% where the output pixels are computed from corresponding patches of input</span>
0014 <span class="comment">% pixels (thus preserving overall image layout). A trivial channel is</span>
0015 <span class="comment">% simply the input grayscale image, likewise for a color image each color</span>
0016 <span class="comment">% channel can serve as a channel. Other channels can be computed using</span>
0017 <span class="comment">% linear or non-linear transformations of I, various choices implemented</span>
0018 <span class="comment">% here are described below. The only constraint is that channels must be</span>
0019 <span class="comment">% translationally invariant (i.e. translating the input image or the</span>
0020 <span class="comment">% resulting channels gives the same result). This allows for fast object</span>
0021 <span class="comment">% detection, as the channels can be computed once on the entire image</span>
0022 <span class="comment">% rather than separately for each overlapping detection window.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% Currently, three channel types are available by default (to date, these</span>
0025 <span class="comment">% have proven the most effective for sliding window object detection):</span>
0026 <span class="comment">%  (1) color channels (computed using rgbConvert.m)</span>
0027 <span class="comment">%  (2) gradient magnitude (computed using gradientMag.m)</span>
0028 <span class="comment">%  (3) quantized gradient channels (computed using gradientHist.m)</span>
0029 <span class="comment">% For more information about each channel type, including the exact input</span>
0030 <span class="comment">% parameters and their meanings, see the respective m-files which perform</span>
0031 <span class="comment">% the actual computatons (chnsCompute is essentially a wrapper function).</span>
0032 <span class="comment">% The converted color channels serve as input to gradientMag/gradientHist.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% Additionally, custom channels can be specified via an optional struct</span>
0035 <span class="comment">% array &quot;pCustom&quot; which may have 0 or more custom channel definitions. Each</span>
0036 <span class="comment">% custom channel is generated via a call to &quot;chns=feval(hFunc,I,pFunc{:})&quot;.</span>
0037 <span class="comment">% The color space of I is determined by pColor.colorSpace, use the setting</span>
0038 <span class="comment">% colorSpace='orig' if the input image is not an 'rgb' image and should be</span>
0039 <span class="comment">% left unchanged (e.g. if I has multiple channels). The input I will have</span>
0040 <span class="comment">% type single and the output of hFunc should also have type single.</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% &quot;shrink&quot; (which should be an integer) determines the amount to subsample</span>
0043 <span class="comment">% the computed channels (in applications such as detection subsamping does</span>
0044 <span class="comment">% not affect performance). The params for each channel type are described</span>
0045 <span class="comment">% in detail in the respective function. In addition, each channel type has</span>
0046 <span class="comment">% a param &quot;enabled&quot; that determines if the channel is computed. If</span>
0047 <span class="comment">% chnsCompute() is called with no inputs, the output is the complete</span>
0048 <span class="comment">% default params (pChns). Otherwise the outputs are the computed channels</span>
0049 <span class="comment">% and additional meta-data (see below). The channels are computed at a</span>
0050 <span class="comment">% single scale, for (fast) multi-scale channel computation see chnsPyramid.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% An emphasis has been placed on speed, with the code undergoing heavy</span>
0053 <span class="comment">% optimization. Computing the full set of channels used in the BMVC09 paper</span>
0054 <span class="comment">% referenced above on a 480x640 image runs over *100 fps* on a single core</span>
0055 <span class="comment">% of a machine from 2011 (although runtime depends on input parameters).</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% USAGE</span>
0058 <span class="comment">%  pChns = chnsCompute()</span>
0059 <span class="comment">%  chns = chnsCompute( I, pChns )</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% INPUTS</span>
0062 <span class="comment">%  I           - [hxwx3] input image (uint8 or single/double in [0,1])</span>
0063 <span class="comment">%  pChns       - parameters (struct or name/value pairs)</span>
0064 <span class="comment">%   .shrink       - [4] integer downsampling amount for channels</span>
0065 <span class="comment">%   .pColor       - parameters for color space:</span>
0066 <span class="comment">%     .enabled      - [1] if true enable color channels</span>
0067 <span class="comment">%     .smooth       - [1] radius for image smoothing (using convTri)</span>
0068 <span class="comment">%     .colorSpace   - ['luv'] choices are: 'gray', 'rgb', 'hsv', 'orig'</span>
0069 <span class="comment">%   .pGradMag     - parameters for gradient magnitude:</span>
0070 <span class="comment">%     .enabled      - [1] if true enable gradient magnitude channel</span>
0071 <span class="comment">%     .colorChn     - [0] if&gt;0 color channel to use for grad computation</span>
0072 <span class="comment">%     .normRad      - [5] normalization radius for gradient</span>
0073 <span class="comment">%     .normConst    - [.005] normalization constant for gradient</span>
0074 <span class="comment">%     .full         - [0] if true compute angles in [0,2*pi) else in [0,pi)</span>
0075 <span class="comment">%   .pGradHist    - parameters for gradient histograms:</span>
0076 <span class="comment">%     .enabled      - [1] if true enable gradient histogram channels</span>
0077 <span class="comment">%     .binSize      - [shrink] spatial bin size (defaults to shrink)</span>
0078 <span class="comment">%     .nOrients     - [6] number of orientation channels</span>
0079 <span class="comment">%     .softBin      - [0] if true use &quot;soft&quot; bilinear spatial binning</span>
0080 <span class="comment">%     .useHog       - [0] if true perform 4-way hog normalization/clipping</span>
0081 <span class="comment">%     .clipHog      - [.2] value at which to clip hog histogram bins</span>
0082 <span class="comment">%   .pCustom      - parameters for custom channels (optional struct array):</span>
0083 <span class="comment">%     .enabled      - [1] if true enable custom channel type</span>
0084 <span class="comment">%     .name         - ['REQ'] custom channel type name</span>
0085 <span class="comment">%     .hFunc        - ['REQ'] function handle for computing custom channels</span>
0086 <span class="comment">%     .pFunc        - [{}] additional params for chns=hFunc(I,pFunc{:})</span>
0087 <span class="comment">%     .padWith      - [0] how channel should be padded (e.g. 0,'replicate')</span>
0088 <span class="comment">%   .complete     - [] if true does not check/set default vals in pChns</span>
0089 <span class="comment">%</span>
0090 <span class="comment">% OUTPUTS</span>
0091 <span class="comment">%  chns       - output struct</span>
0092 <span class="comment">%   .pChns      - exact input parameters used</span>
0093 <span class="comment">%   .nTypes     - number of channel types</span>
0094 <span class="comment">%   .data       - [nTypes x 1] cell [h/shrink x w/shrink x nChns] channels</span>
0095 <span class="comment">%   .info       - [nTypes x 1] struct array</span>
0096 <span class="comment">%     .name       - channel type name</span>
0097 <span class="comment">%     .pChn       - exact input parameters for given channel type</span>
0098 <span class="comment">%     .nChns      - number of channels for given channel type</span>
0099 <span class="comment">%     .padWith    - how channel should be padded (0,'replicate')</span>
0100 <span class="comment">%</span>
0101 <span class="comment">% EXAMPLE - default channels</span>
0102 <span class="comment">%  I=imResample(imread('peppers.png'),[480 640]); pChns=chnsCompute();</span>
0103 <span class="comment">%  tic, for i=1:100, chns=chnsCompute(I,pChns); end; toc</span>
0104 <span class="comment">%  figure(1); montage2(cat(3,chns.data{:}));</span>
0105 <span class="comment">%</span>
0106 <span class="comment">% EXAMPLE - default + custom channels</span>
0107 <span class="comment">%  I=imResample(imread('peppers.png'),[480 640]); pChns=chnsCompute();</span>
0108 <span class="comment">%  hFunc=@(I) 5*sqrt(max(0,max(convBox(I.^2,2)-convBox(I,2).^2,[],3)));</span>
0109 <span class="comment">%  pChns.pCustom=struct('name','Std02','hFunc',hFunc); pChns.complete=0;</span>
0110 <span class="comment">%  tic, chns=chnsCompute(I,pChns); toc</span>
0111 <span class="comment">%  figure(1); im(chns.data{4});</span>
0112 <span class="comment">%</span>
0113 <span class="comment">% See also rgbConvert, gradientMag, gradientHist, chnsPyramid</span>
0114 <span class="comment">%</span>
0115 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.23</span>
0116 <span class="comment">% Copyright 2014 Piotr Dollar &amp; Ron Appel.  [pdollar-at-gmail.com]</span>
0117 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0118 
0119 <span class="comment">% get default parameters pChns</span>
0120 <span class="keyword">if</span>(nargin==2), pChns=varargin{1}; <span class="keyword">else</span> pChns=[]; <span class="keyword">end</span>
0121 <span class="keyword">if</span>( ~isfield(pChns,<span class="string">'complete'</span>) || pChns.complete~=1 || isempty(I) )
0122   p=struct(<span class="string">'enabled'</span>,{},<span class="string">'name'</span>,{},<span class="string">'hFunc'</span>,{},<span class="string">'pFunc'</span>,{},<span class="string">'padWith'</span>,{});
0123   pChns = getPrmDflt(varargin,{<span class="string">'shrink'</span>,4,<span class="string">'pColor'</span>,{},<span class="string">'pGradMag'</span>,{},<span class="keyword">...</span>
0124     <span class="string">'pGradHist'</span>,{},<span class="string">'pCustom'</span>,p,<span class="string">'complete'</span>,1},1);
0125   pChns.pColor = getPrmDflt( pChns.pColor, {<span class="string">'enabled'</span>,1,<span class="keyword">...</span>
0126     <span class="string">'smooth'</span>,1, <span class="string">'colorSpace'</span>,<span class="string">'luv'</span>}, 1 );
0127   pChns.pGradMag = getPrmDflt( pChns.pGradMag, {<span class="string">'enabled'</span>,1,<span class="keyword">...</span>
0128     <span class="string">'colorChn'</span>,0,<span class="string">'normRad'</span>,5,<span class="string">'normConst'</span>,.005,<span class="string">'full'</span>,0}, 1 );
0129   pChns.pGradHist = getPrmDflt( pChns.pGradHist, {<span class="string">'enabled'</span>,1,<span class="keyword">...</span>
0130     <span class="string">'binSize'</span>,[],<span class="string">'nOrients'</span>,6,<span class="string">'softBin'</span>,0,<span class="string">'useHog'</span>,0,<span class="string">'clipHog'</span>,.2}, 1 );
0131   nc=length(pChns.pCustom); pc=cell(1,nc);
0132   <span class="keyword">for</span> i=1:nc, pc{i} = getPrmDflt( pChns.pCustom(i), {<span class="string">'enabled'</span>,1,<span class="keyword">...</span>
0133       <span class="string">'name'</span>,<span class="string">'REQ'</span>,<span class="string">'hFunc'</span>,<span class="string">'REQ'</span>,<span class="string">'pFunc'</span>,{},<span class="string">'padWith'</span>,0}, 1 ); <span class="keyword">end</span>
0134   <span class="keyword">if</span>( nc&gt;0 ), pChns.pCustom=[pc{:}]; <span class="keyword">end</span>
0135 <span class="keyword">end</span>
0136 <span class="keyword">if</span>(nargin==0), chns=pChns; <span class="keyword">return</span>; <span class="keyword">end</span>
0137 
0138 <span class="comment">% create output struct</span>
0139 info=struct(<span class="string">'name'</span>,{},<span class="string">'pChn'</span>,{},<span class="string">'nChns'</span>,{},<span class="string">'padWith'</span>,{});
0140 chns=struct(<span class="string">'pChns'</span>,pChns,<span class="string">'nTypes'</span>,0,<span class="string">'data'</span>,{{}},<span class="string">'info'</span>,info);
0141 
0142 <span class="comment">% crop I so divisible by shrink and get target dimensions</span>
0143 shrink=pChns.shrink; [h,w,~]=size(I); cr=mod([h w],shrink);
0144 <span class="keyword">if</span>(any(cr)), h=h-cr(1); w=w-cr(2); I=I(1:h,1:w,:); <span class="keyword">end</span>
0145 h=h/shrink; w=w/shrink;
0146 
0147 <span class="comment">% compute color channels</span>
0148 p=pChns.pColor; nm=<span class="string">'color channels'</span>;
0149 I=<a href="rgbConvert.html" class="code" title="function J = rgbConvert( I, colorSpace, useSingle )">rgbConvert</a>(I,p.colorSpace); I=<a href="convTri.html" class="code" title="function J = convTri( I, r, s, nomex )">convTri</a>(I,p.smooth);
0150 <span class="keyword">if</span>(p.enabled), chns=<a href="#_sub1" class="code" title="subfunction chns = addChn( chns, data, name, pChn, padWith, h, w )">addChn</a>(chns,I,nm,p,<span class="string">'replicate'</span>,h,w); <span class="keyword">end</span>
0151 
0152 <span class="comment">% compute gradient magnitude channel</span>
0153 p=pChns.pGradMag; nm=<span class="string">'gradient magnitude'</span>;
0154 full=0; <span class="keyword">if</span>(isfield(p,<span class="string">'full'</span>)), full=p.full; <span class="keyword">end</span>
0155 <span class="keyword">if</span>( pChns.pGradHist.enabled )
0156   [M,O]=<a href="gradientMag.html" class="code" title="function [M,O] = gradientMag( I, channel, normRad, normConst, full )">gradientMag</a>(I,p.colorChn,p.normRad,p.normConst,full);
0157 <span class="keyword">elseif</span>( p.enabled )
0158   M=<a href="gradientMag.html" class="code" title="function [M,O] = gradientMag( I, channel, normRad, normConst, full )">gradientMag</a>(I,p.colorChn,p.normRad,p.normConst,full);
0159 <span class="keyword">end</span>
0160 <span class="keyword">if</span>(p.enabled), chns=<a href="#_sub1" class="code" title="subfunction chns = addChn( chns, data, name, pChn, padWith, h, w )">addChn</a>(chns,M,nm,p,0,h,w); <span class="keyword">end</span>
0161 
0162 <span class="comment">% compute gradient histgoram channels</span>
0163 p=pChns.pGradHist; nm=<span class="string">'gradient histogram'</span>;
0164 <span class="keyword">if</span>( p.enabled )
0165   binSize=p.binSize; <span class="keyword">if</span>(isempty(binSize)), binSize=shrink; <span class="keyword">end</span>
0166   H=<a href="gradientHist.html" class="code" title="function H = gradientHist( M, O, varargin )">gradientHist</a>(M,O,binSize,p.nOrients,p.softBin,p.useHog,p.clipHog,full);
0167   chns=<a href="#_sub1" class="code" title="subfunction chns = addChn( chns, data, name, pChn, padWith, h, w )">addChn</a>(chns,H,nm,pChns.pGradHist,0,h,w);
0168 <span class="keyword">end</span>
0169 
0170 <span class="comment">% compute custom channels</span>
0171 p=pChns.pCustom;
0172 <span class="keyword">for</span> i=find( [p.enabled] )
0173   C=feval(p(i).hFunc,I,p(i).pFunc{:});
0174   chns=<a href="#_sub1" class="code" title="subfunction chns = addChn( chns, data, name, pChn, padWith, h, w )">addChn</a>(chns,C,p(i).name,p(i),p(i).padWith,h,w);
0175 <span class="keyword">end</span>
0176 
0177 <span class="keyword">end</span>
0178 
0179 <a name="_sub1" href="#_subfunctions" class="code">function chns = addChn( chns, data, name, pChn, padWith, h, w )</a>
0180 <span class="comment">% Helper function to add a channel to chns.</span>
0181 [h1,w1,~]=size(data);
0182 <span class="keyword">if</span>(h1~=h || w1~=w), data=imResampleMex(data,h,w,1);
0183   assert(all(mod([h1 w1]./[h w],1)==0)); <span class="keyword">end</span>
0184 chns.data{end+1}=data; chns.nTypes=chns.nTypes+1;
0185 chns.info(end+1)=struct(<span class="string">'name'</span>,name,<span class="string">'pChn'</span>,pChn,<span class="keyword">...</span>
0186   <span class="string">'nChns'</span>,size(data,3),<span class="string">'padWith'</span>,padWith);
0187 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>