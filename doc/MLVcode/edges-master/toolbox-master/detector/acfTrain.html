<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of acfTrain</title>
  <meta name="keywords" content="acfTrain">
  <meta name="description" content="Train aggregate channel features object detector.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="../../../index.html">MLVcode</a> &gt; <a href="../../index.html">edges-master</a> &gt; <a href="#">toolbox-master</a> &gt; <a href="index.html">detector</a> &gt; acfTrain.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for MLVcode\edges-master\toolbox-master\detector&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>acfTrain
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Train aggregate channel features object detector.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function detector = acfTrain( varargin ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Train aggregate channel features object detector.

 Train aggregate channel features (ACF) object detector as described in:
  P. Dollár, R. Appel, S. Belongie and P. Perona
   &quot;Fast Feature Pyramids for Object Detection&quot;, PAMI 2014.
 The ACF detector is fast (30 fps on a single core) and achieves top
 accuracy on rigid object detection. Please see acfReadme.m for details.

 Takes a set of parameters opts (described in detail below) and trains a
 detector from start to finish including performing multiple rounds of
 bootstrapping if need be. The return is a struct 'detector' for use with
 acfDetect.m which fully defines a sliding window detector. Training is
 fast (on the INRIA pedestrian dataset training takes ~10 minutes on a
 single core or ~3m using four cores). Taking advantage of parallel
 training requires launching matlabpool (see help for matlabpool). The
 trained detector may be altered in certain ways via acfModify(). Calling
 opts=acfTrain() returns all default options.

 (1) Specifying features and model: The channel features are defined by
 'pPyramid'. See chnsCompute.m and chnsPyramid.m for more details. The
 channels may be convolved by a set 'filters' to remove local correlations
 (see our NIPS14 paper on LDCF), improving accuracy but slowing detection.
 If 'filters'=[wFilter,nFilter] these are automatically computed. The
 model dimensions ('modelDs') define the window height and width. The
 padded dimensions ('modelDsPad') define the extended region around object
 candidates that are used for classification. For example, for 100 pixel
 tall pedestrians, typically a 128 pixel tall region is used to make a
 decision. 'pNms' controls non-maximal suppression (see bbNms.m), 'stride'
 controls the window stride, and 'cascThr' and 'cascCal' are the threshold
 and calibration used for the constant soft cascades. Typically, set
 'cascThr' to -1 and adjust 'cascCal' until the desired recall is reached
 (setting 'cascCal' shifts the final scores output by the detector by the
 given amount). Training alternates between sampling (bootstrapping) and
 training an AdaBoost classifier (clf). 'nWeak' determines the number of
 training stages and number of trees after each stage, e.g. nWeak=[32 128
 512 2048] defines four stages with the final clf having 2048 trees.
 'pBoost' specifies parameters for AdaBoost, and 'pBoost.pTree' are the
 decision tree parameters, see adaBoostTrain.m for details. Finally,
 'seed' is the random seed used and makes results reproducible and 'name'
 defines the location for storing the detector and log file.

 (2) Specifying training data location and amount: The training data can
 take on a number of different forms. The positives can be specified using
 either a dir of pre-cropped windows ('posWinDir') or dirs of full images
 ('posImgDir') and ground truth labels ('posGtDir'). The negatives can by
 specified using a dir of pre-cropped windows ('negWinDir'), a dir of full
 images without any positives and from which negatives can be sampled
 ('negImgDir'), and finally if neither 'negWinDir' or 'negImgDir' are
 given negatives are sampled from the images in 'posImgDir' (avoiding the
 positives). For the pre-cropped windows all images must have size at
 least modelDsPad and have the object (of size exactly modelDs) centered.
 'imreadf' can be used to specify a custom function for loading an image,
 and 'imreadp' are custom additional parameters to imreadf. When sampling
 from full images, 'pLoad' determines how the ground truth is loaded and
 converted to a set of positive bbs (see bbGt&gt;bbLoad). 'nPos' controls the
 total number of positives to sample for training (if nPos=inf the number
 of positives is limited by the training set). 'nNeg' controls the total
 number of negatives to sample and 'nPerNeg' limits the number of
 negatives to sample per image. 'nAccNeg' controls the maximum number of
 negatives that can accumulate over multiple stages of bootstrapping.
 Define 'pJitter' to jitter the positives (see jitterImage.m) and thus
 artificially increase the number of positive training windows. Finally if
 'winsSave' is true cropped windows are saved to disk as a mat file.

 USAGE
  detector = acfTrain( opts )
  opts = acfTrain()

 INPUTS
  opts       - parameters (struct or name/value pairs)
   (1) features and model:
   .pPyramid   - [{}] params for creating pyramid (see chnsPyramid)
   .filters    - [] [wxwxnChnsxnFilter] filters or [wFilter,nFilter]
   .modelDs    - [] model height+width without padding (eg [100 41])
   .modelDsPad - [] model height+width with padding (eg [128 64])
   .pNms       - [..] params for non-maximal suppression (see bbNms.m)
   .stride     - [4] spatial stride between detection windows
   .cascThr    - [-1] constant cascade threshold (affects speed/accuracy)
   .cascCal    - [.005] cascade calibration (affects speed/accuracy)
   .nWeak      - [128] vector defining number weak clfs per stage
   .pBoost     - [..] parameters for boosting (see adaBoostTrain.m)
   .seed       - [0] seed for random stream (for reproducibility)
   .name       - [''] name to prepend to clf and log filenames
   (2) training data location and amount:
   .posGtDir   - [''] dir containing ground truth
   .posImgDir  - [''] dir containing full positive images
   .negImgDir  - [''] dir containing full negative images
   .posWinDir  - [''] dir containing cropped positive windows
   .negWinDir  - [''] dir containing cropped negative windows
   .imreadf    - [@imread] optional custom function for reading images
   .imreadp    - [{}] optional custom parameters for imreadf
   .pLoad      - [..] params for bbGt&gt;bbLoad (see bbGt)
   .nPos       - [inf] max number of pos windows to sample
   .nNeg       - [5000] max number of neg windows to sample
   .nPerNeg    - [25]  max number of neg windows to sample per image
   .nAccNeg    - [10000] max number of neg windows to accumulate
   .pJitter    - [{}] params for jittering pos windows (see jitterImage)
   .winsSave   - [0] if true save cropped windows at each stage to disk

 OUTPUTS
  detector   - trained object detector (modify only via acfModify)
   .opts       - input parameters used for model training
   .clf        - learned boosted tree classifier (see adaBoostTrain)
   .info       - info about channels (see chnsCompute.m)

 EXAMPLE

 See also <a href="acfReadme.html" class="code" title="">acfReadme</a>, <a href="acfDetect.html" class="code" title="function bbs = acfDetect( I, detector, fileName )">acfDetect</a>, <a href="acfDemoInria.html" class="code" title="">acfDemoInria</a>, <a href="acfModify.html" class="code" title="function detector = acfModify( detector, varargin )">acfModify</a>, <a href="acfTest.html" class="code" title="function [miss,roc,gt,dt] = acfTest( varargin )">acfTest</a>,
 chnsCompute, chnsPyramid, adaBoostTrain, <a href="bbGt.html" class="code" title="function varargout = bbGt( action, varargin )">bbGt</a>, <a href="bbNms.html" class="code" title="function bbs = bbNms( bbs, varargin )">bbNms</a>, jitterImage

 Piotr's Computer Vision Matlab Toolbox      Version 3.50
 Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]
 Licensed under the Simplified BSD License [see external/bsd.txt]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="acfDetect.html" class="code" title="function bbs = acfDetect( I, detector, fileName )">acfDetect</a>	Run aggregate channel features object detector on given image(s).</li><li><a href="bbApply.html" class="code" title="function varargout = bbApply( action, varargin )">bbApply</a>	Functions for manipulating bounding boxes (bb).</li><li><a href="bbGt.html" class="code" title="function varargout = bbGt( action, varargin )">bbGt</a>	Bounding box (bb) annotations struct, evaluation and sampling routines.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="acfDemoCal.html" class="code" title="">acfDemoCal</a>	Demo for aggregate channel features object detector on Caltech dataset.</li><li><a href="acfDemoInria.html" class="code" title="">acfDemoInria</a>	Demo for aggregate channel features object detector on Inria dataset.</li><li><a href="acfSweeps.html" class="code" title="function acfSweeps">acfSweeps</a>	Parameter sweeps for ACF pedestrian detector.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function opts = initializeOpts( varargin )</a></li><li><a href="#_sub2" class="code">function [Is,IsOrig] = sampleWins( detector, stage, positive )</a></li><li><a href="#_sub3" class="code">function Is = sampleWins1( I, gt, detector, stage, positive )</a></li><li><a href="#_sub4" class="code">function chns = chnsCompute1( Is, opts )</a></li><li><a href="#_sub5" class="code">function filters = chnsCorrelation( chns, wFilter, nFilter )</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function detector = acfTrain( varargin )</a>
0002 <span class="comment">% Train aggregate channel features object detector.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Train aggregate channel features (ACF) object detector as described in:</span>
0005 <span class="comment">%  P. Dollár, R. Appel, S. Belongie and P. Perona</span>
0006 <span class="comment">%   &quot;Fast Feature Pyramids for Object Detection&quot;, PAMI 2014.</span>
0007 <span class="comment">% The ACF detector is fast (30 fps on a single core) and achieves top</span>
0008 <span class="comment">% accuracy on rigid object detection. Please see acfReadme.m for details.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Takes a set of parameters opts (described in detail below) and trains a</span>
0011 <span class="comment">% detector from start to finish including performing multiple rounds of</span>
0012 <span class="comment">% bootstrapping if need be. The return is a struct 'detector' for use with</span>
0013 <span class="comment">% acfDetect.m which fully defines a sliding window detector. Training is</span>
0014 <span class="comment">% fast (on the INRIA pedestrian dataset training takes ~10 minutes on a</span>
0015 <span class="comment">% single core or ~3m using four cores). Taking advantage of parallel</span>
0016 <span class="comment">% training requires launching matlabpool (see help for matlabpool). The</span>
0017 <span class="comment">% trained detector may be altered in certain ways via acfModify(). Calling</span>
0018 <span class="comment">% opts=acfTrain() returns all default options.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% (1) Specifying features and model: The channel features are defined by</span>
0021 <span class="comment">% 'pPyramid'. See chnsCompute.m and chnsPyramid.m for more details. The</span>
0022 <span class="comment">% channels may be convolved by a set 'filters' to remove local correlations</span>
0023 <span class="comment">% (see our NIPS14 paper on LDCF), improving accuracy but slowing detection.</span>
0024 <span class="comment">% If 'filters'=[wFilter,nFilter] these are automatically computed. The</span>
0025 <span class="comment">% model dimensions ('modelDs') define the window height and width. The</span>
0026 <span class="comment">% padded dimensions ('modelDsPad') define the extended region around object</span>
0027 <span class="comment">% candidates that are used for classification. For example, for 100 pixel</span>
0028 <span class="comment">% tall pedestrians, typically a 128 pixel tall region is used to make a</span>
0029 <span class="comment">% decision. 'pNms' controls non-maximal suppression (see bbNms.m), 'stride'</span>
0030 <span class="comment">% controls the window stride, and 'cascThr' and 'cascCal' are the threshold</span>
0031 <span class="comment">% and calibration used for the constant soft cascades. Typically, set</span>
0032 <span class="comment">% 'cascThr' to -1 and adjust 'cascCal' until the desired recall is reached</span>
0033 <span class="comment">% (setting 'cascCal' shifts the final scores output by the detector by the</span>
0034 <span class="comment">% given amount). Training alternates between sampling (bootstrapping) and</span>
0035 <span class="comment">% training an AdaBoost classifier (clf). 'nWeak' determines the number of</span>
0036 <span class="comment">% training stages and number of trees after each stage, e.g. nWeak=[32 128</span>
0037 <span class="comment">% 512 2048] defines four stages with the final clf having 2048 trees.</span>
0038 <span class="comment">% 'pBoost' specifies parameters for AdaBoost, and 'pBoost.pTree' are the</span>
0039 <span class="comment">% decision tree parameters, see adaBoostTrain.m for details. Finally,</span>
0040 <span class="comment">% 'seed' is the random seed used and makes results reproducible and 'name'</span>
0041 <span class="comment">% defines the location for storing the detector and log file.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% (2) Specifying training data location and amount: The training data can</span>
0044 <span class="comment">% take on a number of different forms. The positives can be specified using</span>
0045 <span class="comment">% either a dir of pre-cropped windows ('posWinDir') or dirs of full images</span>
0046 <span class="comment">% ('posImgDir') and ground truth labels ('posGtDir'). The negatives can by</span>
0047 <span class="comment">% specified using a dir of pre-cropped windows ('negWinDir'), a dir of full</span>
0048 <span class="comment">% images without any positives and from which negatives can be sampled</span>
0049 <span class="comment">% ('negImgDir'), and finally if neither 'negWinDir' or 'negImgDir' are</span>
0050 <span class="comment">% given negatives are sampled from the images in 'posImgDir' (avoiding the</span>
0051 <span class="comment">% positives). For the pre-cropped windows all images must have size at</span>
0052 <span class="comment">% least modelDsPad and have the object (of size exactly modelDs) centered.</span>
0053 <span class="comment">% 'imreadf' can be used to specify a custom function for loading an image,</span>
0054 <span class="comment">% and 'imreadp' are custom additional parameters to imreadf. When sampling</span>
0055 <span class="comment">% from full images, 'pLoad' determines how the ground truth is loaded and</span>
0056 <span class="comment">% converted to a set of positive bbs (see bbGt&gt;bbLoad). 'nPos' controls the</span>
0057 <span class="comment">% total number of positives to sample for training (if nPos=inf the number</span>
0058 <span class="comment">% of positives is limited by the training set). 'nNeg' controls the total</span>
0059 <span class="comment">% number of negatives to sample and 'nPerNeg' limits the number of</span>
0060 <span class="comment">% negatives to sample per image. 'nAccNeg' controls the maximum number of</span>
0061 <span class="comment">% negatives that can accumulate over multiple stages of bootstrapping.</span>
0062 <span class="comment">% Define 'pJitter' to jitter the positives (see jitterImage.m) and thus</span>
0063 <span class="comment">% artificially increase the number of positive training windows. Finally if</span>
0064 <span class="comment">% 'winsSave' is true cropped windows are saved to disk as a mat file.</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% USAGE</span>
0067 <span class="comment">%  detector = acfTrain( opts )</span>
0068 <span class="comment">%  opts = acfTrain()</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% INPUTS</span>
0071 <span class="comment">%  opts       - parameters (struct or name/value pairs)</span>
0072 <span class="comment">%   (1) features and model:</span>
0073 <span class="comment">%   .pPyramid   - [{}] params for creating pyramid (see chnsPyramid)</span>
0074 <span class="comment">%   .filters    - [] [wxwxnChnsxnFilter] filters or [wFilter,nFilter]</span>
0075 <span class="comment">%   .modelDs    - [] model height+width without padding (eg [100 41])</span>
0076 <span class="comment">%   .modelDsPad - [] model height+width with padding (eg [128 64])</span>
0077 <span class="comment">%   .pNms       - [..] params for non-maximal suppression (see bbNms.m)</span>
0078 <span class="comment">%   .stride     - [4] spatial stride between detection windows</span>
0079 <span class="comment">%   .cascThr    - [-1] constant cascade threshold (affects speed/accuracy)</span>
0080 <span class="comment">%   .cascCal    - [.005] cascade calibration (affects speed/accuracy)</span>
0081 <span class="comment">%   .nWeak      - [128] vector defining number weak clfs per stage</span>
0082 <span class="comment">%   .pBoost     - [..] parameters for boosting (see adaBoostTrain.m)</span>
0083 <span class="comment">%   .seed       - [0] seed for random stream (for reproducibility)</span>
0084 <span class="comment">%   .name       - [''] name to prepend to clf and log filenames</span>
0085 <span class="comment">%   (2) training data location and amount:</span>
0086 <span class="comment">%   .posGtDir   - [''] dir containing ground truth</span>
0087 <span class="comment">%   .posImgDir  - [''] dir containing full positive images</span>
0088 <span class="comment">%   .negImgDir  - [''] dir containing full negative images</span>
0089 <span class="comment">%   .posWinDir  - [''] dir containing cropped positive windows</span>
0090 <span class="comment">%   .negWinDir  - [''] dir containing cropped negative windows</span>
0091 <span class="comment">%   .imreadf    - [@imread] optional custom function for reading images</span>
0092 <span class="comment">%   .imreadp    - [{}] optional custom parameters for imreadf</span>
0093 <span class="comment">%   .pLoad      - [..] params for bbGt&gt;bbLoad (see bbGt)</span>
0094 <span class="comment">%   .nPos       - [inf] max number of pos windows to sample</span>
0095 <span class="comment">%   .nNeg       - [5000] max number of neg windows to sample</span>
0096 <span class="comment">%   .nPerNeg    - [25]  max number of neg windows to sample per image</span>
0097 <span class="comment">%   .nAccNeg    - [10000] max number of neg windows to accumulate</span>
0098 <span class="comment">%   .pJitter    - [{}] params for jittering pos windows (see jitterImage)</span>
0099 <span class="comment">%   .winsSave   - [0] if true save cropped windows at each stage to disk</span>
0100 <span class="comment">%</span>
0101 <span class="comment">% OUTPUTS</span>
0102 <span class="comment">%  detector   - trained object detector (modify only via acfModify)</span>
0103 <span class="comment">%   .opts       - input parameters used for model training</span>
0104 <span class="comment">%   .clf        - learned boosted tree classifier (see adaBoostTrain)</span>
0105 <span class="comment">%   .info       - info about channels (see chnsCompute.m)</span>
0106 <span class="comment">%</span>
0107 <span class="comment">% EXAMPLE</span>
0108 <span class="comment">%</span>
0109 <span class="comment">% See also acfReadme, acfDetect, acfDemoInria, acfModify, acfTest,</span>
0110 <span class="comment">% chnsCompute, chnsPyramid, adaBoostTrain, bbGt, bbNms, jitterImage</span>
0111 <span class="comment">%</span>
0112 <span class="comment">% Piotr's Computer Vision Matlab Toolbox      Version 3.50</span>
0113 <span class="comment">% Copyright 2014 Piotr Dollar.  [pdollar-at-gmail.com]</span>
0114 <span class="comment">% Licensed under the Simplified BSD License [see external/bsd.txt]</span>
0115 
0116 <span class="comment">% initialize opts struct</span>
0117 opts = <a href="#_sub1" class="code" title="subfunction opts = initializeOpts( varargin )">initializeOpts</a>( varargin{:} );
0118 <span class="keyword">if</span>(nargin==0), detector=opts; <span class="keyword">return</span>; <span class="keyword">end</span>
0119 
0120 <span class="comment">% load or initialize detector and begin logging</span>
0121 nm=[opts.name <span class="string">'Detector.mat'</span>]; t=exist(nm,<span class="string">'file'</span>);
0122 <span class="keyword">if</span>(t), <span class="keyword">if</span>(nargout), t=load(nm); detector=t.detector; <span class="keyword">end</span>; <span class="keyword">return</span>; <span class="keyword">end</span>
0123 t=fileparts(nm); <span class="keyword">if</span>(~isempty(t) &amp;&amp; ~exist(t,<span class="string">'dir'</span>)), mkdir(t); <span class="keyword">end</span>
0124 detector = struct( <span class="string">'opts'</span>,opts, <span class="string">'clf'</span>,[], <span class="string">'info'</span>,[] );
0125 startTrain=clock; nm=[opts.name <span class="string">'Log.txt'</span>];
0126 <span class="keyword">if</span>(exist(nm,<span class="string">'file'</span>)), diary(nm); diary(<span class="string">'off'</span>); delete(nm); <span class="keyword">end</span>; diary(nm);
0127 RandStream.setGlobalStream(RandStream(<span class="string">'mrg32k3a'</span>,<span class="string">'Seed'</span>,opts.seed));
0128 
0129 <span class="comment">% iterate bootstraping and training</span>
0130 <span class="keyword">for</span> stage = 0:numel(opts.nWeak)-1
0131   diary(<span class="string">'on'</span>); fprintf([repmat(<span class="string">'-'</span>,[1 75]) <span class="string">'\n'</span>]);
0132   fprintf(<span class="string">'Training stage %i\n'</span>,stage); startStage=clock;
0133   
0134   <span class="comment">% sample positives and compute info about channels</span>
0135   <span class="keyword">if</span>( stage==0 )
0136     [Is1,IsOrig1] = <a href="#_sub2" class="code" title="subfunction [Is,IsOrig] = sampleWins( detector, stage, positive )">sampleWins</a>( detector, stage, 1 );
0137     t=ndims(Is1); <span class="keyword">if</span>(t==3), t=Is1(:,:,1); <span class="keyword">else</span> t=Is1(:,:,:,1); <span class="keyword">end</span>
0138     t=chnsCompute(t,opts.pPyramid.pChns); detector.info=t.info;
0139   <span class="keyword">end</span>
0140   
0141   <span class="comment">% compute local decorrelation filters</span>
0142   <span class="keyword">if</span>( stage==0 &amp;&amp; length(opts.filters)==2 )
0143     fs = opts.filters; opts.filters = [];
0144     X1 = <a href="#_sub4" class="code" title="subfunction chns = chnsCompute1( Is, opts )">chnsCompute1</a>( IsOrig1, opts );
0145     fs = <a href="#_sub5" class="code" title="subfunction filters = chnsCorrelation( chns, wFilter, nFilter )">chnsCorrelation</a>( X1, fs(1), fs(2) );
0146     opts.filters = fs; detector.opts.filters = fs;
0147   <span class="keyword">end</span>
0148   
0149   <span class="comment">% compute lambdas</span>
0150   <span class="keyword">if</span>( stage==0 &amp;&amp; isempty(opts.pPyramid.lambdas) )
0151     fprintf(<span class="string">'Computing lambdas... '</span>); start=clock;
0152     ds=size(IsOrig1); ds(1:end-1)=1; IsOrig1=mat2cell2(IsOrig1,ds);
0153     ls=chnsScaling(opts.pPyramid.pChns,IsOrig1,0);
0154     ls=round(ls*10^5)/10^5; detector.opts.pPyramid.lambdas=ls;
0155     fprintf(<span class="string">'done (time=%.0fs).\n'</span>,etime(clock,start));
0156   <span class="keyword">end</span>
0157   
0158   <span class="comment">% compute features for positives</span>
0159   <span class="keyword">if</span>( stage==0 )
0160     X1 = <a href="#_sub4" class="code" title="subfunction chns = chnsCompute1( Is, opts )">chnsCompute1</a>( Is1, opts );
0161     X1 = reshape(X1,[],size(X1,4))';
0162     clear Is1 IsOrig1 ls fs ds t;
0163   <span class="keyword">end</span>
0164   
0165   <span class="comment">% sample negatives and compute features</span>
0166   Is0 = <a href="#_sub2" class="code" title="subfunction [Is,IsOrig] = sampleWins( detector, stage, positive )">sampleWins</a>( detector, stage, 0 );
0167   X0 = <a href="#_sub4" class="code" title="subfunction chns = chnsCompute1( Is, opts )">chnsCompute1</a>( Is0, opts ); clear Is0;
0168   X0 = reshape(X0,[],size(X0,4))';
0169   
0170   <span class="comment">% accumulate negatives from previous stages</span>
0171   <span class="keyword">if</span>( stage&gt;0 )
0172     n0=size(X0p,1); n1=max(opts.nNeg,opts.nAccNeg)-size(X0,1);
0173     <span class="keyword">if</span>(n0&gt;n1 &amp;&amp; n1&gt;0), X0p=X0p(randSample(n0,n1),:); <span class="keyword">end</span>
0174     <span class="keyword">if</span>(n0&gt;0 &amp;&amp; n1&gt;0), X0=[X0p; X0]; <span class="keyword">end</span> <span class="comment">%#ok&lt;AGROW&gt;</span>
0175   <span class="keyword">end</span>; X0p=X0;
0176   
0177   <span class="comment">% train boosted clf</span>
0178   detector.opts.pBoost.nWeak = opts.nWeak(stage+1);
0179   detector.clf = adaBoostTrain(X0,X1,detector.opts.pBoost);
0180   detector.clf.hs = detector.clf.hs + opts.cascCal;
0181   
0182   <span class="comment">% update log</span>
0183   fprintf(<span class="string">'Done training stage %i (time=%.0fs).\n'</span>,<span class="keyword">...</span>
0184     stage,etime(clock,startStage)); diary(<span class="string">'off'</span>);
0185 <span class="keyword">end</span>
0186 
0187 <span class="comment">% save detector</span>
0188 save([opts.name <span class="string">'Detector.mat'</span>],<span class="string">'detector'</span>);
0189 
0190 <span class="comment">% finalize logging</span>
0191 diary(<span class="string">'on'</span>); fprintf([repmat(<span class="string">'-'</span>,[1 75]) <span class="string">'\n'</span>]);
0192 fprintf(<span class="string">'Done training (time=%.0fs).\n'</span>,<span class="keyword">...</span>
0193   etime(clock,startTrain)); diary(<span class="string">'off'</span>);
0194 
0195 <span class="keyword">end</span>
0196 
0197 <a name="_sub1" href="#_subfunctions" class="code">function opts = initializeOpts( varargin )</a>
0198 <span class="comment">% Initialize opts struct.</span>
0199 dfs= { <span class="string">'pPyramid'</span>,{}, <span class="string">'filters'</span>,[], <span class="keyword">...</span>
0200   <span class="string">'modelDs'</span>,[100 41], <span class="string">'modelDsPad'</span>,[128 64], <span class="keyword">...</span>
0201   <span class="string">'pNms'</span>,struct(), <span class="string">'stride'</span>,4, <span class="string">'cascThr'</span>,-1, <span class="string">'cascCal'</span>,.005, <span class="keyword">...</span>
0202   <span class="string">'nWeak'</span>,128, <span class="string">'pBoost'</span>, {}, <span class="string">'seed'</span>,0, <span class="string">'name'</span>,<span class="string">''</span>, <span class="string">'posGtDir'</span>,<span class="string">''</span>, <span class="keyword">...</span>
0203   <span class="string">'posImgDir'</span>,<span class="string">''</span>, <span class="string">'negImgDir'</span>,<span class="string">''</span>, <span class="string">'posWinDir'</span>,<span class="string">''</span>, <span class="string">'negWinDir'</span>,<span class="string">''</span>, <span class="keyword">...</span>
0204   <span class="string">'imreadf'</span>,@imread, <span class="string">'imreadp'</span>,{}, <span class="string">'pLoad'</span>,{}, <span class="string">'nPos'</span>,inf, <span class="string">'nNeg'</span>,5000, <span class="keyword">...</span>
0205   <span class="string">'nPerNeg'</span>,25, <span class="string">'nAccNeg'</span>,10000, <span class="string">'pJitter'</span>,{}, <span class="string">'winsSave'</span>,0 };
0206 opts = getPrmDflt(varargin,dfs,1);
0207 <span class="comment">% fill in remaining parameters</span>
0208 p=chnsPyramid([],opts.pPyramid); p=p.pPyramid;
0209 p.minDs=opts.modelDs; shrink=p.pChns.shrink;
0210 opts.modelDsPad=ceil(opts.modelDsPad/shrink)*shrink;
0211 p.pad=ceil((opts.modelDsPad-opts.modelDs)/shrink/2)*shrink;
0212 p=chnsPyramid([],p); p=p.pPyramid; p.complete=1;
0213 p.pChns.complete=1; opts.pPyramid=p;
0214 <span class="comment">% initialize pNms, pBoost, pBoost.pTree, and pLoad</span>
0215 dfs={ <span class="string">'type'</span>,<span class="string">'maxg'</span>, <span class="string">'overlap'</span>,.65, <span class="string">'ovrDnm'</span>,<span class="string">'min'</span> };
0216 opts.pNms=getPrmDflt(opts.pNms,dfs,-1);
0217 dfs={ <span class="string">'pTree'</span>,{}, <span class="string">'nWeak'</span>,0, <span class="string">'discrete'</span>,1, <span class="string">'verbose'</span>,16 };
0218 opts.pBoost=getPrmDflt(opts.pBoost,dfs,1);
0219 dfs={<span class="string">'nBins'</span>,256,<span class="string">'maxDepth'</span>,2,<span class="string">'minWeight'</span>,.01,<span class="string">'fracFtrs'</span>,1,<span class="string">'nThreads'</span>,16};
0220 opts.pBoost.pTree=getPrmDflt(opts.pBoost.pTree,dfs,1);
0221 opts.pLoad=getPrmDflt(opts.pLoad,{<span class="string">'squarify'</span>,{0,1}},-1);
0222 opts.pLoad.squarify{2}=opts.modelDs(2)/opts.modelDs(1);
0223 <span class="keyword">end</span>
0224 
0225 <a name="_sub2" href="#_subfunctions" class="code">function [Is,IsOrig] = sampleWins( detector, stage, positive )</a>
0226 <span class="comment">% Load or sample windows for training detector.</span>
0227 opts=detector.opts; start=clock;
0228 <span class="keyword">if</span>( positive ), n=opts.nPos; <span class="keyword">else</span> n=opts.nNeg; <span class="keyword">end</span>
0229 <span class="keyword">if</span>( positive ), crDir=opts.posWinDir; <span class="keyword">else</span> crDir=opts.negWinDir; <span class="keyword">end</span>
0230 <span class="keyword">if</span>( exist(crDir,<span class="string">'dir'</span>) &amp;&amp; stage==0 )
0231   <span class="comment">% if window directory is specified simply load windows</span>
0232   fs=<a href="bbGt.html" class="code" title="function varargout = bbGt( action, varargin )">bbGt</a>(<span class="string">'getFiles'</span>,{crDir}); nImg=length(fs); assert(nImg&gt;0);
0233   <span class="keyword">if</span>(nImg&gt;n), fs=fs(:,randSample(nImg,n)); <span class="keyword">else</span> n=nImg; <span class="keyword">end</span>
0234   <span class="keyword">for</span> i=1:n, fs{i}=[{opts.imreadf},fs(i),opts.imreadp]; <span class="keyword">end</span>
0235   Is=cell(1,n); parfor i=1:n, Is{i}=feval(fs{i}{:}); <span class="keyword">end</span>
0236 <span class="keyword">else</span>
0237   <span class="comment">% sample windows from full images using sampleWins1()</span>
0238   hasGt=positive||isempty(opts.negImgDir); fs={opts.negImgDir};
0239   <span class="keyword">if</span>(hasGt), fs={opts.posImgDir,opts.posGtDir}; <span class="keyword">end</span>
0240   fs=<a href="bbGt.html" class="code" title="function varargout = bbGt( action, varargin )">bbGt</a>(<span class="string">'getFiles'</span>,fs); nImg=size(fs,2); assert(nImg&gt;0);
0241   <span class="keyword">if</span>(~isinf(n)), fs=fs(:,randperm(nImg)); <span class="keyword">end</span>; Is=cell(nImg*1000,1);
0242   diary(<span class="string">'off'</span>); tid=ticStatus(<span class="string">'Sampling windows'</span>,1,30); k=0; i=0; batch=64;
0243   <span class="keyword">while</span>( i&lt;nImg &amp;&amp; k&lt;n )
0244     batch=min(batch,nImg-i); Is1=cell(1,batch);
0245     parfor j=1:batch, ij=i+j;
0246       I = feval(opts.imreadf,fs{1,ij},opts.imreadp{:}); <span class="comment">%#ok&lt;PFBNS&gt;</span>
0247       gt=[]; <span class="keyword">if</span>(hasGt), [~,gt]=<a href="bbGt.html" class="code" title="function varargout = bbGt( action, varargin )">bbGt</a>(<span class="string">'bbLoad'</span>,fs{2,ij},opts.pLoad); <span class="keyword">end</span>
0248       Is1{j} = <a href="#_sub3" class="code" title="subfunction Is = sampleWins1( I, gt, detector, stage, positive )">sampleWins1</a>( I, gt, detector, stage, positive );
0249     <span class="keyword">end</span>
0250     Is1=[Is1{:}]; k1=length(Is1); Is(k+1:k+k1)=Is1; k=k+k1;
0251     <span class="keyword">if</span>(k&gt;n), Is=Is(randSample(k,n)); k=n; <span class="keyword">end</span>
0252     i=i+batch; tocStatus(tid,max(i/nImg,k/n));
0253   <span class="keyword">end</span>
0254   Is=Is(1:k); diary(<span class="string">'on'</span>);
0255   fprintf(<span class="string">'Sampled %i windows from %i images.\n'</span>,k,i);
0256 <span class="keyword">end</span>
0257 <span class="comment">% optionally jitter positive windows</span>
0258 <span class="keyword">if</span>(length(Is)&lt;2), Is={}; <span class="keyword">return</span>; <span class="keyword">end</span>
0259 nd=ndims(Is{1})+1; Is=cat(nd,Is{:}); IsOrig=Is;
0260 <span class="keyword">if</span>( positive &amp;&amp; isstruct(opts.pJitter) )
0261   opts.pJitter.hasChn=(nd==4); Is=jitterImage(Is,opts.pJitter);
0262   ds=size(Is); ds(nd)=ds(nd)*ds(nd+1); Is=reshape(Is,ds(1:nd));
0263 <span class="keyword">end</span>
0264 <span class="comment">% make sure dims are divisible by shrink and not smaller than modelDsPad</span>
0265 ds=size(Is); cr=rem(ds(1:2),opts.pPyramid.pChns.shrink); s=floor(cr/2)+1;
0266 e=ceil(cr/2); Is=Is(s(1):end-e(1),s(2):end-e(2),:,:); ds=size(Is);
0267 <span class="keyword">if</span>(any(ds(1:2)&lt;opts.modelDsPad)), error(<span class="string">'Windows too small.'</span>); <span class="keyword">end</span>
0268 <span class="comment">% optionally save windows to disk and update log</span>
0269 nm=[opts.name <span class="string">'Is'</span> int2str(positive) <span class="string">'Stage'</span> int2str(stage)];
0270 <span class="keyword">if</span>( opts.winsSave ), save(nm,<span class="string">'Is'</span>,<span class="string">'-v7.3'</span>); <span class="keyword">end</span>
0271 fprintf(<span class="string">'Done sampling windows (time=%.0fs).\n'</span>,etime(clock,start));
0272 diary(<span class="string">'off'</span>); diary(<span class="string">'on'</span>);
0273 <span class="keyword">end</span>
0274 
0275 <a name="_sub3" href="#_subfunctions" class="code">function Is = sampleWins1( I, gt, detector, stage, positive )</a>
0276 <span class="comment">% Sample windows from I given its ground truth gt.</span>
0277 opts=detector.opts; shrink=opts.pPyramid.pChns.shrink;
0278 modelDs=opts.modelDs; modelDsPad=opts.modelDsPad;
0279 <span class="keyword">if</span>( positive ), bbs=gt; bbs=bbs(bbs(:,5)==0,:); <span class="keyword">else</span>
0280   <span class="keyword">if</span>( stage==0 )
0281     <span class="comment">% generate candidate bounding boxes in a grid</span>
0282     [h,w,~]=size(I); h1=modelDs(1); w1=modelDs(2);
0283     n=opts.nPerNeg; ny=sqrt(n*h/w); nx=n/ny; ny=ceil(ny); nx=ceil(nx);
0284     [xs,ys]=meshgrid(linspace(1,w-w1,nx),linspace(1,h-h1,ny));
0285     bbs=[xs(:) ys(:)]; bbs(:,3)=w1; bbs(:,4)=h1; bbs=bbs(1:n,:);
0286   <span class="keyword">else</span>
0287     <span class="comment">% run detector to generate candidate bounding boxes</span>
0288     bbs=<a href="acfDetect.html" class="code" title="function bbs = acfDetect( I, detector, fileName )">acfDetect</a>(I,detector); [~,ord]=sort(bbs(:,5),<span class="string">'descend'</span>);
0289     bbs=bbs(ord(1:min(<span class="keyword">end</span>,opts.nPerNeg)),1:4);
0290   <span class="keyword">end</span>
0291   <span class="keyword">if</span>( ~isempty(gt) )
0292     <span class="comment">% discard any candidate negative bb that matches the gt</span>
0293     n=size(bbs,1); keep=false(1,n);
0294     <span class="keyword">for</span> i=1:n, keep(i)=all(<a href="bbGt.html" class="code" title="function varargout = bbGt( action, varargin )">bbGt</a>(<span class="string">'compOas'</span>,bbs(i,:),gt,gt(:,5))&lt;.1); <span class="keyword">end</span>
0295     bbs=bbs(keep,:);
0296   <span class="keyword">end</span>
0297 <span class="keyword">end</span>
0298 <span class="comment">% grow bbs to a large padded size and finally crop windows</span>
0299 modelDsBig=max(8*shrink,modelDsPad)+max(2,ceil(64/shrink))*shrink;
0300 r=modelDs(2)/modelDs(1); assert(all(abs(bbs(:,3)./bbs(:,4)-r)&lt;1e-5));
0301 r=modelDsBig./modelDs; bbs=<a href="bbApply.html" class="code" title="function varargout = bbApply( action, varargin )">bbApply</a>(<span class="string">'resize'</span>,bbs,r(1),r(2));
0302 Is=<a href="bbApply.html" class="code" title="function varargout = bbApply( action, varargin )">bbApply</a>(<span class="string">'crop'</span>,I,bbs,<span class="string">'replicate'</span>,modelDsBig([2 1]));
0303 <span class="keyword">end</span>
0304 
0305 <a name="_sub4" href="#_subfunctions" class="code">function chns = chnsCompute1( Is, opts )</a>
0306 <span class="comment">% Compute single scale channels of dimensions modelDsPad.</span>
0307 <span class="keyword">if</span>(isempty(Is)), chns=[]; <span class="keyword">return</span>; <span class="keyword">end</span>
0308 fprintf(<span class="string">'Extracting features... '</span>); start=clock; fs=opts.filters;
0309 pChns=opts.pPyramid.pChns; smooth=opts.pPyramid.smooth;
0310 dsTar=opts.modelDsPad/pChns.shrink; ds=size(Is); ds(1:end-1)=1;
0311 Is=squeeze(mat2cell2(Is,ds)); n=length(Is); chns=cell(1,n);
0312 parfor i=1:n
0313   C=chnsCompute(Is{i},pChns); C=convTri(cat(3,C.data{:}),smooth);
0314   <span class="keyword">if</span>(~isempty(fs)), C=repmat(C,[1 1 size(fs,4)]);
0315     <span class="keyword">for</span> j=1:size(C,3), C(:,:,j)=conv2(C(:,:,j),fs(:,:,j),<span class="string">'same'</span>); <span class="keyword">end</span>; <span class="keyword">end</span>
0316   <span class="keyword">if</span>(~isempty(fs)), C=imResample(C,.5); shr=2; <span class="keyword">else</span> shr=1; <span class="keyword">end</span>
0317   ds=size(C); cr=ds(1:2)-dsTar/shr; s=floor(cr/2)+1; e=ceil(cr/2);
0318   C=C(s(1):end-e(1),s(2):end-e(2),:); chns{i}=C;
0319 <span class="keyword">end</span>; chns=cat(4,chns{:});
0320 fprintf(<span class="string">'done (time=%.0fs).\n'</span>,etime(clock,start));
0321 <span class="keyword">end</span>
0322 
0323 <a name="_sub5" href="#_subfunctions" class="code">function filters = chnsCorrelation( chns, wFilter, nFilter )</a>
0324 <span class="comment">% Compute filters capturing local correlations for each channel.</span>
0325 fprintf(<span class="string">'Computing correlations... '</span>); start=clock;
0326 [~,~,m,n]=size(chns); w=wFilter; wp=w*2-1;
0327 filters=zeros(w,w,m,nFilter,<span class="string">'single'</span>);
0328 <span class="keyword">for</span> i=1:m
0329   <span class="comment">% compute local auto-scorrelation using Wiener-Khinchin theorem</span>
0330   mus=squeeze(mean(mean(chns(:,:,i,:)))); sig=cell(1,n);
0331   parfor j=1:n
0332     T=fftshift(ifft2(abs(fft2(chns(:,:,i,j)-mean(mus))).^2));
0333     sig{j}=T(floor(end/2)+1-w+(1:wp),floor(end/2)+1-w+(1:wp));
0334   <span class="keyword">end</span>
0335   sig=double(mean(cat(4,sig{mus&gt;1/50}),4));
0336   sig=reshape(full(convmtx2(sig,w,w)),wp+w-1,wp+w-1,[]);
0337   sig=reshape(sig(w:wp,w:wp,:),w^2,w^2); sig=(sig+sig')/2;
0338   <span class="comment">% compute filters for each channel from sig (sorted by eigenvalue)</span>
0339   [fs,D]=eig(sig); fs=reshape(fs,w,w,[]);
0340   [~,ord]=sort(diag(D),<span class="string">'descend'</span>);
0341   fs=flipdim(flipdim(fs,1),2); <span class="comment">%#ok&lt;DFLIPDIM&gt;</span>
0342   filters(:,:,i,:)=fs(:,:,ord(1:nFilter));
0343 <span class="keyword">end</span>
0344 fprintf(<span class="string">'done (time=%.0fs).\n'</span>,etime(clock,start));
0345 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 05-May-2022 14:52:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>